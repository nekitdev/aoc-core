{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"<code>aoc-core</code>","text":"<p>Advent of Code in Python.</p>"},{"location":"#installing","title":"Installing","text":"<p>Python 3.8 or above is required.</p>"},{"location":"#pip","title":"pip","text":"<p>Installing the library with <code>pip</code> is quite simple:</p> <pre><code>$ pip install aoc-core\n</code></pre> <p>Alternatively, the library can be installed from source:</p> <pre><code>$ git clone https://github.com/nekitdev/aoc-core.git\n$ cd aoc-core\n$ python -m pip install .\n</code></pre>"},{"location":"#poetry","title":"poetry","text":"<p>You can add <code>aoc-core</code> as a dependency with the following command:</p> <pre><code>$ poetry add aoc-core\n</code></pre> <p>Or by directly specifying it in the configuration like so:</p> <pre><code>[tool.poetry.dependencies]\naoc-core = \"^0.1.0\"\n</code></pre> <p>Alternatively, you can add it directly from the source:</p> <pre><code>[tool.poetry.dependencies.aoc-core]\ngit = \"https://github.com/nekitdev/aoc-core.git\"\n</code></pre>"},{"location":"#extras","title":"Extras","text":"<p><code>aoc-core</code> provides an extra <code>ext</code>, which installs modules like <code>iters</code>, <code>funcs</code> and <code>wraps</code> which can help solving problems in functional style.</p>"},{"location":"#example","title":"Example","text":"<p>This example assumes <code>aoc</code> is installed and in <code>PATH</code>.</p> <p>We will be solving problem the first ever problem of Advent of Code, that is, <code>2015-01</code>.</p> <p>Firstly, we need to make sure we have the token configured:</p> <pre><code>$ aoc token print\ntoken not found (path `/home/nekit/.aoc`)\n</code></pre> <p>Note that the token is placed in <code>~/.aoc</code> by default.</p> <p>Heading over to the Advent of Code website, we need to trace the requests and find the <code>session</code> cookie. This is the token we need to add:</p> <pre><code>$ aoc token set {TOKEN}\n</code></pre> <p>And now recheck:</p> <pre><code>$ aoc token print\n{TOKEN}\n</code></pre> <p>Secondly, we need to download the data for the problem:</p> <pre><code>$ aoc download\nYear: 2015\nDay: 01\n(... lots of brackets ...)\n</code></pre> <p>And we are met by our input data! In order to run the solutions, we need to save this.</p> <pre><code>$ aoc download --year 2015 --day 01 --save\n</code></pre> <p>Or, if you want to be quicker:</p> <pre><code>$ aoc download -y 2015 -d 01 -s\n</code></pre> <p>Now we have everything ready to solve the problem!</p> <p>In order to define solutions, we need to figure out three types to use:</p> <ul> <li><code>I</code>, the input type that we parse the data into;</li> <li><code>T</code>, the answer type for the first part of the problem;</li> <li><code>U</code>, the answer type for the second part of the problem.</li> </ul> <p>Since the problem is about navigating the given string and we return integers, our types will be: <code>I = str</code>, <code>T = int</code> and possibly <code>U = int</code>.</p> <p>To define the solution, we need to derive from <code>Solution</code>:</p> <pre><code># example.py\n\nfrom aoc.solutions import Solution\n\n\nclass Year2015Day01(Solution[str, int, int]):\n    ...\n</code></pre> <p>Note the class name, <code>Year2015Day01</code>. This is the convention for naming solutions, and all solutions must have their name in the <code>YearYYYYDayDD</code> format.</p> <p>We also need to define three methods:</p> <ul> <li><code>parse</code>, which takes the data string and returns <code>I</code>;</li> <li><code>solve_one</code>, which takes <code>I</code> and returns <code>T</code>;</li> <li><code>solve_two</code>, which takes <code>I</code> and returns <code>U</code>.</li> </ul> <p>Part one is rather simple, we need to count the occurrences of <code>(</code> and <code>)</code>, and subtract the latter from the former:</p> <pre><code>from typing import Final\n\nfrom aoc.solutions import Solution\n\nUP: Final = \"(\"\nDOWN: Final = \")\"\n\n\nclass Year2015Day01(Solution[str, int, int]):\n    def parse(self, data: str) -&gt; str:\n        return data\n\n    def solve_one(self, input: str) -&gt; int:\n        return input.count(UP) - input.count(DOWN)\n\n    def solve_two(self, input: str) -&gt; int:\n        return 0\n</code></pre> <p>Since we don't yet know what part two is about, let's return <code>0</code> for now.</p> <p>Time to run!</p> <pre><code>$ aoc run example.py\nresult for `2015-01`\n    answer one: {ONE}\n    answer two: 0\n    parse time: 1.018us\n    solve one time: 41.401us\n    solve two time: 245.0ns\n</code></pre> <p>We have our answer for part one, let's submit it!</p> <pre><code>$ aoc submit --year 2015 --day 01 --part 1 {ONE}\nthe answer is correct\n</code></pre> <p>By the way, we can submit the answer directly after running the solution, using the <code>--submit (-s)</code> flag.</p> <p>Now onto part two! We need to find the first position where the floor is <code>-1</code>.</p> <p>Nothing too difficult, here is the solution for part two included:</p> <pre><code>from typing import Final\n\nfrom aoc.solutions import Solution\n\nUP: Final = \"(\"\nDOWN: Final = \")\"\n\nNEVER_REACHED_BASEMENT: Final = \"the basement was never reached\"\n\n\nclass Year2015Day01(Solution[str, int, int]):\n    def parse(self, data: str) -&gt; str:\n        return data\n\n    def solve_one(self, input: str) -&gt; int:\n        return input.count(UP) - input.count(DOWN)\n\n    def solve_two(self, input: str) -&gt; int:\n        up = UP\n        down = DOWN\n\n        floor = 0\n\n        for position, character in enumerate(input, 1):  # one-based indexing\n            if character == up:\n                floor += 1\n\n            if character == down:\n                floor -= 1\n\n            if floor &lt; 0:\n                return position\n\n        raise ValueError(NEVER_REACHED_BASEMENT)\n</code></pre> <p>And let's run the solution again:</p> <pre><code>$ aoc run example.py\nresult for `2015-01`\n    answer one: {ONE}\n    answer two: {TWO}\n    parse time: 989.0ns\n    solve one time: 41.607us\n    solve two time: 59.411us\n</code></pre> <p>We have our answer for part two, let's submit it!</p> <pre><code>$ aoc submit -y 2015 -d 01 -p 2 {TWO}\nthe answer is correct\n</code></pre> <p>And there we go, we have solved the first ever problem in the Advent of Code!</p>"},{"location":"#documentation","title":"Documentation","text":"<p>You can find the documentation here.</p>"},{"location":"#support","title":"Support","text":"<p>If you need support with the library, you can send an email or refer to the official Discord server.</p>"},{"location":"#changelog","title":"Changelog","text":"<p>You can find the changelog here.</p>"},{"location":"#security-policy","title":"Security Policy","text":"<p>You can find the Security Policy of <code>aoc-core</code> here.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are interested in contributing to <code>aoc-core</code>, make sure to take a look at the Contributing Guide, as well as the Code of Conduct.</p>"},{"location":"#license","title":"License","text":"<p><code>aoc-core</code> is licensed under the MIT License terms. See License for details.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"code_of_conduct/","title":"Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement to conduct@nekit.dev.</p> <p>All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://contributor-covenant.org/version/2/1/code_of_conduct.</p> <p>Community Impact Guidelines were inspired by Mozilla's Code of Conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://contributor-covenant.org/faq. Translations are available at https://contributor-covenant.org/translations.</p>"},{"location":"security/","title":"Security Policy","text":""},{"location":"security/#reporting","title":"Reporting","text":"<p>Thank you for taking the time to responsibly disclose any problems you find.</p> <p>Do not file public issues as they are open for everyone to see!</p> <p>All security vulnerabilities in <code>aoc-core</code> should be reported by email to security@nekit.dev. Your report will be acknowledged within 24 hours, and you will receive a more detailed response within 48 hours indicating the next steps in handling your report.</p> <p>You can encrypt your report using our public key: <code>6AF9DDF87B37BBE6E83F5DF2B8F5B86F98F12F5E</code>. This key is also available on MIT's Key Server and reproduced below.</p> <p>After the initial reply to your report, the core team will try to keep you informed of the progress being made towards a fix and official announcement. These updates will be sent at least every five days. In reality, this is more likely to be every 24-48 hours.</p>"},{"location":"security/#disclosure-policy","title":"Disclosure Policy","text":"<p><code>aoc-core</code> has a 5-step disclosure process:</p> <ol> <li> <p>The security report is received and is assigned a primary handler.    This person will coordinate the fix and release process.</p> </li> <li> <p>The problem is confirmed and a list of all affected versions is determined.</p> </li> <li> <p>Code is audited to find any potential similar problems.</p> </li> <li> <p>Fixes are prepared for all releases which are still under maintenance.    These fixes are not committed to the public repository but rather    held locally pending the announcement.</p> </li> <li> <p>On the embargo date, the changes are pushed to the public repository    and new builds are deployed.</p> </li> </ol> <p>This process can take some time, especially when coordination is required with maintainers of other projects. Every effort will be made to handle the issue in as timely a manner as possible, however it is important that we follow the release process above to ensure that the disclosure is handled in a consistent manner.</p>"},{"location":"security/#security-key","title":"Security Key","text":"<pre><code>-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nmQINBGVV4JcBEAC7PTswfzA2iMTVSig51NVDV08XABrR01qslTfhIVw6Uwr2iCoY\nF+hkNn3++pgoF95Fx/iREDFV/AG4GGKl1GbAI3YD6aOoh0FGWtxg3MMa3oHjRUZs\nf0VwKk8sA5d21V05OiMuptAqxXuLrdR5SINtxKE10H6K9o22988VOmWUCIEaxKM5\nM5HCfhe8fl5pKpdIf3i1F073qset4DXGkvm/v+dWYHPvv0NlHhnJ5Lcaq4aTvkEg\ny2NhDobR4VpdP1aQZbEONussUaKLxBTBJN5NNnf7SI1qVYcaglYrXM7uQGXuL32X\nXAILtOCM0LO2059Z7ZMkI6lkkbei1j08j2Tha/1GvN2rIClNyV912GvAQhzlwhdT\nWmk+ymrwbed7MkRW3IB3b1zFb7Dhz6a5yBS8iT5ikkrGaR/i7O3V/DS02j7Rao2k\nnfXIncuBuXSXb1pIhCuYuV6VYBgFWfpKDjOzEy83h3DSI/jrR31e6aiBes+fyFRG\nIuoFRTsaMq2T9M5F6pDvmtoexHxXevYoSt+7DURY1pSWnk4MjZUj7yDFPSyfPleZ\naNq/3aGQt7vnY5QgyGjKaX5jSVuNEKsUlhrKUWt9weoJrF5ZyYHY0RPg1q1Fz0mY\nZ7QWeaKA0uOeziG0bHf6yNEzxnaYCfi09/WOL4GH0pBsdubNHpWno/D6PwARAQAB\ntC9OaWtpdGEgVGlraG9ub3YgKHNlY3VyaXR5KSA8c2VjdXJpdHlAbmVraXQuZGV2\nPokCTgQTAQoAOBYhBGr53fh7N7vm6D9d8rj1uG+Y8S9eBQJlVeCXAhsDBQsJCAcC\nBhUKCQgLAgQWAgMBAh4BAheAAAoJELj1uG+Y8S9ed4kP+wYE1OZtcWoRSK2Xqvaf\nP5+YcXC1vdCZ16depb6kGOR91G9eEMJhSDlSzzUzOmkvT4TknZi/Y17m9TvQccET\nSwgWvDs9XwMby24mkxD1iYu2uIZXXhRbIKJPi4EpGgamEveYLLTd0L8yX2l/YXuq\nVcM4vqgRtnovlW+cCUmmtpRcb+Ldfxu2RixjnG4fznzzlMOnU0zpWUMBqH+mSyfH\nRmY5vgOR/adgQcIviQdhRPMC4TAa3GNdTd2Qpxo3xelum15yLKxkm/EvBSPsL1fj\nJQBYnZFk4KBKNiXXYwWuU0mpOx1TMtYPVnHer17QL0vXfsmVNkXVzucvrNfHpFc9\nhXzmm5wHwMrGClyQBA6sDWDfQOKYibQTcKzyJr2Gl31luNPSRchzC4lbosLzRkqh\nYh5dco+ITiKDe7g54w+Fy+KdumwN/GvBlQptGIpaxA1+xAbNVs+fDo+WrQEL+AZO\nOQR91YUsjIdvVdk5BcgUYvEe2YyyMZ7LSqWACpRknqz5FNcdmO2bz7jl732EYLRm\nQ90oSG6xcIFuPZRNVIUJds9Gg2u1PBV5z0vnFGiJ6NK6DrYYecMKU9uAQUZcSW8v\n+fn92V0DkVeOfeMbq4yytZx5W4VrsWT1XyfjTzg867jzmo1JmZQeZ4KXh7AYRlC6\nn8NwYZ13+pUFeTPm9jCwJMrGuQINBGVV4JcBEACg5zXucth9KIdryYUxyBgA7Ist\nhJmyxtSHSiKRFOiQBmQqHeQgDdCnBeDw+cb+8wB4NL3PNw5xHKRvQGTWaBTV1IPf\nCV3P2c/sZLDCU8PNMu3lsmEbN2ippOiJi1fw478EGlNity8ktI+TEhsdniypKoiw\nDNf3wdawWiraODM9KuYplcsnFHl5r97BjHR0EbOOKkTc4PwysQ7WVHZ/nwGzNb5T\nCI7A/TF0RTL/Wkdz7WZM7r5BELz+z0ksjsS8eMObtm/uG4lfAmbIGohPTlir4WWL\n/GYZpAjvv/6zNaydMpY3uQKrdqN05j10uYnkbsclwSBBbRovFBRWEInbO0cqpzc0\nJiWt4U91F6UNbSDPo3KaiDjJXDb7cr4gQv0C1T9LtmKSfY/JVcUj7csGXslOAvXf\nz08iDCJu3zj7QjZPKA1/MxmTo88hAvhHlOYrXaaRjzXt6r9+qdDxVYJGe9K3LkJS\n9Yc0U9xBGAfzw9Ebs/ZPDtjgupPHJXq6VBSndU3c53jr7SEZBIFMPg75CeJJ6IgH\nA4zwW1uzalZi3mYWWCKiGhDBPOo5yGwKocxMzSuerlMW21fjhOMymSKVksteJlmZ\nAy6ExDNOK663V6iFnsn4iIFbE1jOznHhSsbyKqQ/QukpMqAyrQVSNyutXVl0VuW0\nZsZeFff7ScnrTgB7/QARAQABiQI2BBgBCgAgFiEEavnd+Hs3u+boP13yuPW4b5jx\nL14FAmVV4JcCGwwACgkQuPW4b5jxL15jNw/9EQkahEieTABEKAKxGetODA7HTiNR\ncM3aKgDU0msYjfgfAi+wQzx/8k8Yf/Kjma6JqsksCj0ygFkXS87tOAUfJTpgmKVS\nV3XaDXFwTcdG0+/Cx5RllduJmnLTLSuvm2uxu7ErPGtnYWBw88nmQ/8f9nkmvCsY\nCuF6DHAUNzTLgerFKSGNMwOv6kKBCgNkstclcHp5YbzssN1w34dPV/swuCjc+6JM\nnW5WuPD3R2Y9522Ov/bEwr9raFf3R5A6ETK4GOZUqNmPG4MJgbyiJlk96TuF06mO\nnFpKnBtxD+t20jAFTMRokyiQT65X8KnrpT8CpTJ6xzmBO5IYGhUSqt3CH/YzwqRa\nv9FTJ/qSPM5OXPH4pK7VzNDVhEPQhLAGENLwOnasnXXGvj/MQIRYyjGAXQfB34a7\nz0x4rQ+fyaody6BW10KJBQuRrB3dPaOPU3LU/4TxzyudDxiOJGiWAlw56a2lviEG\nJExMJrSvP5kiCfPlLZiLfqaw2ZYeyosnv8bmC4H2Sr9IEggtCyrzNOoJQx+w/f/L\n6a14Cshc3UYLC+0yh74Mc5vUu2SfwI6zSevjI1LWj4qc592J/q3QNHiJN9F60tyP\nr46uNM25Y+C5qgVneqRjHmWSIdOvYXcBTLj03eDiQHCJz3ZT6ztLwQxQ800MS1Yd\npbmAGLbBB2TBok4=\n=Ir8m\n-----END PGP PUBLIC KEY BLOCK-----\n</code></pre>"},{"location":"security/#attribution","title":"Attribution","text":"<p>This Security Policy is adapted from Rust's Security Policy.</p>"},{"location":"reference/constants/","title":"Constants","text":""},{"location":"reference/constants/#aoc.constants.ROOT","title":"<code>ROOT = Path(__file__).parent</code>  <code>module-attribute</code>","text":"<p>The root of the library.</p>"},{"location":"reference/constants/#aoc.constants.HOME","title":"<code>HOME = Path.home()</code>  <code>module-attribute</code>","text":"<p>The user's home directory (<code>~/</code>).</p>"},{"location":"reference/constants/#aoc.constants.TOKEN_NAME","title":"<code>TOKEN_NAME = '.aoc'</code>  <code>module-attribute</code>","text":"<p>The name of the token file.</p>"},{"location":"reference/constants/#aoc.constants.TOKEN_PATH","title":"<code>TOKEN_PATH = HOME / TOKEN_NAME</code>  <code>module-attribute</code>","text":"<p>The path to the token file.</p>"},{"location":"reference/constants/#aoc.constants.CACHE_NAME","title":"<code>CACHE_NAME = '.cache'</code>  <code>module-attribute</code>","text":"<p>The name of the cache directory.</p>"},{"location":"reference/constants/#aoc.constants.AOC_NAME","title":"<code>AOC_NAME = 'aoc'</code>  <code>module-attribute</code>","text":"<p>The name of the Advent of Code directory.</p>"},{"location":"reference/constants/#aoc.constants.DATA_NAME","title":"<code>DATA_NAME = 'data'</code>  <code>module-attribute</code>","text":"<p>The name of the data directory.</p>"},{"location":"reference/constants/#aoc.constants.DATA_PATH","title":"<code>DATA_PATH = HOME / CACHE_NAME / AOC_NAME / DATA_NAME</code>  <code>module-attribute</code>","text":"<p>The path to the data directory.</p>"},{"location":"reference/constants/#aoc.constants.FIRST_YEAR","title":"<code>FIRST_YEAR: Literal[2015] = 2015</code>  <code>module-attribute</code>","text":"<p>The first year of the Advent of Code.</p>"},{"location":"reference/constants/#aoc.constants.FIRST_DAY","title":"<code>FIRST_DAY: Literal[1] = 1</code>  <code>module-attribute</code>","text":"<p>The first day of the Advent of Code.</p>"},{"location":"reference/constants/#aoc.constants.LAST_DAY","title":"<code>LAST_DAY: Literal[25] = 25</code>  <code>module-attribute</code>","text":"<p>The last day of the Advent of Code.</p>"},{"location":"reference/constants/#aoc.constants.EMPTY","title":"<code>EMPTY = str()</code>  <code>module-attribute</code>","text":"<p>The empty string.</p>"},{"location":"reference/constants/#aoc.constants.NEW_LINE","title":"<code>NEW_LINE = '\\n'</code>  <code>module-attribute</code>","text":"<p>The new line character.</p>"},{"location":"reference/constants/#aoc.constants.DEFAULT_ROUNDING","title":"<code>DEFAULT_ROUNDING = 5</code>  <code>module-attribute</code>","text":"<p>The default rounding for timers.</p>"},{"location":"reference/constants/#aoc.constants.NAME","title":"<code>NAME = 'aoc-core'</code>  <code>module-attribute</code>","text":"<p>The name of the library.</p>"},{"location":"reference/constants/#aoc.constants.PYTHON","title":"<code>PYTHON = 'python'</code>  <code>module-attribute</code>","text":"<p>The <code>python</code> literal.</p>"},{"location":"reference/constants/#aoc.constants.HEAD","title":"<code>HEAD = 'HEAD'</code>  <code>module-attribute</code>","text":"<p>The <code>HEAD</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.GET","title":"<code>GET = 'GET'</code>  <code>module-attribute</code>","text":"<p>The <code>GET</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.POST","title":"<code>POST = 'POST'</code>  <code>module-attribute</code>","text":"<p>The <code>POST</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.PUT","title":"<code>PUT = 'PUT'</code>  <code>module-attribute</code>","text":"<p>The <code>PUT</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.PATCH","title":"<code>PATCH = 'PATCH'</code>  <code>module-attribute</code>","text":"<p>The <code>PATCH</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.DELETE","title":"<code>DELETE = 'DELETE'</code>  <code>module-attribute</code>","text":"<p>The <code>DELETE</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.CONNECT","title":"<code>CONNECT = 'CONNECT'</code>  <code>module-attribute</code>","text":"<p>The <code>CONNECT</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.OPTIONS","title":"<code>OPTIONS = 'OPTIONS'</code>  <code>module-attribute</code>","text":"<p>The <code>OPTIONS</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.TRACE","title":"<code>TRACE = 'TRACE'</code>  <code>module-attribute</code>","text":"<p>The <code>TRACE</code> HTTP method.</p>"},{"location":"reference/constants/#aoc.constants.TOKEN_COOKIE_NAME","title":"<code>TOKEN_COOKIE_NAME = 'session'</code>  <code>module-attribute</code>","text":"<p>The cookie name to send the token in.</p>"},{"location":"reference/constants/#aoc.constants.BASE_URL","title":"<code>BASE_URL = URL('https://adventofcode.com/')</code>  <code>module-attribute</code>","text":"<p>The Advent of Code base URL.</p>"},{"location":"reference/constants/#aoc.constants.DEFAULT_RETRIES","title":"<code>DEFAULT_RETRIES = 3</code>  <code>module-attribute</code>","text":"<p>The default amount of retries to use.</p>"},{"location":"reference/constants/#aoc.constants.PART","title":"<code>PART = 'level'</code>  <code>module-attribute</code>","text":"<p>The part of the problem to solve (for payloads).</p>"},{"location":"reference/constants/#aoc.constants.ANSWER","title":"<code>ANSWER = 'answer'</code>  <code>module-attribute</code>","text":"<p>The answer to the problem (for payloads).</p>"},{"location":"reference/constants/#aoc.constants.DEFAULT_ENCODING","title":"<code>DEFAULT_ENCODING = 'utf-8'</code>  <code>module-attribute</code>","text":"<p>The default encoding to use.</p>"},{"location":"reference/constants/#aoc.constants.DEFAULT_ERRORS","title":"<code>DEFAULT_ERRORS = 'strict'</code>  <code>module-attribute</code>","text":"<p>The default error handling of the encoding to use.</p>"},{"location":"reference/data/","title":"Data","text":""},{"location":"reference/data/#aoc.data.get_path_for_key","title":"<code>get_path_for_key(key: Key, data_path: Path = DATA_PATH) -&gt; Path</code>","text":"<p>Gets the path to the file in <code>data_path</code> for the given <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Key</code> <p>The key to get the path for.</p> required <code>data_path</code> <code>Path</code> <p>The path to the data directory.</p> <code>DATA_PATH</code> <p>Returns:</p> Type Description <code>Path</code> <p>The path to the file in <code>data_path</code> for the given <code>key</code>.</p> Source code in <code>aoc/data.py</code> <pre><code>def get_path_for_key(key: Key, data_path: Path = DATA_PATH) -&gt; Path:\n    \"\"\"Gets the path to the file in `data_path` for the given `key`.\n\n    Arguments:\n        key: The key to get the path for.\n        data_path: The path to the data directory.\n\n    Returns:\n        The path to the file in `data_path` for the given `key`.\n    \"\"\"\n    return data_path / str(key.year) / str(key.day)\n</code></pre>"},{"location":"reference/data/#aoc.data.load_data","title":"<code>load_data(key: Key, data_path: Path = DATA_PATH, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS) -&gt; str</code>","text":"<p>Loads the data for the given <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Key</code> <p>The key to load the data for.</p> required <code>data_path</code> <code>Path</code> <p>The path to the data directory.</p> <code>DATA_PATH</code> <code>encoding</code> <code>str</code> <p>The encoding to use.</p> <code>DEFAULT_ENCODING</code> <code>errors</code> <code>str</code> <p>The error handling of the encoding to use.</p> <code>DEFAULT_ERRORS</code> <p>Returns:</p> Type Description <code>str</code> <p>The data for the given <code>key</code>.</p> <p>Raises:</p> Type Description <code>DataNotFound</code> <p><code>OSError</code> occured.</p> Source code in <code>aoc/data.py</code> <pre><code>def load_data(\n    key: Key,\n    data_path: Path = DATA_PATH,\n    encoding: str = DEFAULT_ENCODING,\n    errors: str = DEFAULT_ERRORS,\n) -&gt; str:\n    \"\"\"Loads the data for the given `key`.\n\n    Arguments:\n        key: The key to load the data for.\n        data_path: The path to the data directory.\n        encoding: The encoding to use.\n        errors: The error handling of the encoding to use.\n\n    Returns:\n        The data for the given `key`.\n\n    Raises:\n        DataNotFound: [`OSError`][OSError] occured.\n    \"\"\"\n    try:\n        return get_path_for_key(key, data_path).read_text(encoding, errors)\n\n    except OSError as origin:\n        raise DataNotFound(key, data_path) from origin\n</code></pre>"},{"location":"reference/data/#aoc.data.dump_data","title":"<code>dump_data(data: str, key: Key, data_path: Path = DATA_PATH, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS) -&gt; None</code>","text":"<p>Dumps the <code>data</code> for the given <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to dump.</p> required <code>key</code> <code>Key</code> <p>The key to dump the data for.</p> required <code>data_path</code> <code>Path</code> <p>The path to the data directory.</p> <code>DATA_PATH</code> <code>encoding</code> <code>str</code> <p>The encoding to use.</p> <code>DEFAULT_ENCODING</code> <code>errors</code> <code>str</code> <p>The error handling of the encoding to use.</p> <code>DEFAULT_ERRORS</code> Source code in <code>aoc/data.py</code> <pre><code>def dump_data(\n    data: str,\n    key: Key,\n    data_path: Path = DATA_PATH,\n    encoding: str = DEFAULT_ENCODING,\n    errors: str = DEFAULT_ERRORS,\n) -&gt; None:\n    \"\"\"Dumps the `data` for the given `key`.\n\n    Arguments:\n        data: The data to dump.\n        key: The key to dump the data for.\n        data_path: The path to the data directory.\n        encoding: The encoding to use.\n        errors: The error handling of the encoding to use.\n    \"\"\"\n    path = get_path_for_key(key, data_path)\n\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    path.write_text(data, encoding, errors)\n</code></pre>"},{"location":"reference/errors/","title":"Errors","text":""},{"location":"reference/errors/#aoc.errors.TokenNotFound","title":"<code>TokenNotFound</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>The token was not found.</p> Source code in <code>aoc/errors.py</code> <pre><code>class TokenNotFound(RuntimeError):\n    \"\"\"The token was not found.\"\"\"\n\n    def __init__(self, path: Path) -&gt; None:\n        super().__init__(token_not_found(path.as_posix()))\n\n        self._path = path\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"The token path.\"\"\"\n        return self._path\n</code></pre>"},{"location":"reference/errors/#aoc.errors.TokenNotFound.path","title":"<code>path: Path</code>  <code>property</code>","text":"<p>The token path.</p>"},{"location":"reference/errors/#aoc.errors.DataNotFound","title":"<code>DataNotFound</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>The data for the problem was not found.</p> Source code in <code>aoc/errors.py</code> <pre><code>class DataNotFound(RuntimeError):\n    \"\"\"The data for the problem was not found.\"\"\"\n\n    def __init__(self, key: Key, path: Path) -&gt; None:\n        super().__init__(data_not_found(key, path.as_posix()))\n\n        self._key = key\n        self._path = path\n\n    @property\n    def key(self) -&gt; Key:\n        \"\"\"The key of the problem.\"\"\"\n        return self._key\n\n    @property\n    def path(self) -&gt; Path:\n        \"\"\"The path to the problem's data file.\"\"\"\n        return self._path\n</code></pre>"},{"location":"reference/errors/#aoc.errors.DataNotFound.key","title":"<code>key: Key</code>  <code>property</code>","text":"<p>The key of the problem.</p>"},{"location":"reference/errors/#aoc.errors.DataNotFound.path","title":"<code>path: Path</code>  <code>property</code>","text":"<p>The path to the problem's data file.</p>"},{"location":"reference/errors/#aoc.errors.InternalError","title":"<code>InternalError</code>","text":"<p>             Bases: <code>RuntimeError</code></p> <p>Represents internal errors in the library.</p> Source code in <code>aoc/errors.py</code> <pre><code>class InternalError(RuntimeError):\n    \"\"\"Represents internal errors in the library.\"\"\"\n</code></pre>"},{"location":"reference/http/","title":"HTTP","text":""},{"location":"reference/http/#aoc.http.USER_AGENT_LITERAL","title":"<code>USER_AGENT_LITERAL = 'User-Agent'</code>  <code>module-attribute</code>","text":"<p>The user agent literal.</p>"},{"location":"reference/http/#aoc.http.USER_AGENT","title":"<code>USER_AGENT = f'{NAME}/{version_info} ({PYTHON}/{python_version_info})'</code>  <code>module-attribute</code>","text":"<p>The user agent to use.</p> <p>This is formatted using:</p> <ul> <li><code>NAME</code>;</li> <li><code>version_info</code>;</li> <li><code>PYTHON</code>;</li> <li><code>python_version_info</code>.</li> </ul>"},{"location":"reference/http/#aoc.http.HEADERS","title":"<code>HEADERS = {USER_AGENT_LITERAL: USER_AGENT}</code>  <code>module-attribute</code>","text":"<p>The default headers to use.</p>"},{"location":"reference/http/#aoc.http.Route","title":"<code>Route</code>","text":"<p>Represents routes.</p> Source code in <code>aoc/http.py</code> <pre><code>@frozen()\nclass Route:\n    \"\"\"Represents routes.\"\"\"\n\n    method: str\n    \"\"\"The HTTP method of the route.\"\"\"\n\n    path: str\n    \"\"\"The path of the route.\"\"\"\n\n    @classmethod\n    def with_parameters(cls, method: str, path: str, **parameters: Any) -&gt; Self:\n        \"\"\"Constructs a route with `path` formatted using `parameters`.\n\n        Arguments:\n            method: The HTTP method of the route.\n            path: The path template of the route.\n            **parameters: The parameters to format `path` with.\n\n        Returns:\n            The route constructed.\n        \"\"\"\n        return cls(method, path.format_map(parameters))\n\n    @property\n    def key(self) -&gt; str:\n        \"\"\"The key of the route.\"\"\"\n        return key(route=self)\n</code></pre>"},{"location":"reference/http/#aoc.http.Route.method","title":"<code>method: str</code>  <code>instance-attribute</code>","text":"<p>The HTTP method of the route.</p>"},{"location":"reference/http/#aoc.http.Route.path","title":"<code>path: str</code>  <code>instance-attribute</code>","text":"<p>The path of the route.</p>"},{"location":"reference/http/#aoc.http.Route.key","title":"<code>key: str</code>  <code>property</code>","text":"<p>The key of the route.</p>"},{"location":"reference/http/#aoc.http.Route.with_parameters","title":"<code>with_parameters(method: str, path: str, **parameters: Any) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Constructs a route with <code>path</code> formatted using <code>parameters</code>.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method of the route.</p> required <code>path</code> <code>str</code> <p>The path template of the route.</p> required <code>**parameters</code> <code>Any</code> <p>The parameters to format <code>path</code> with.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Self</code> <p>The route constructed.</p> Source code in <code>aoc/http.py</code> <pre><code>@classmethod\ndef with_parameters(cls, method: str, path: str, **parameters: Any) -&gt; Self:\n    \"\"\"Constructs a route with `path` formatted using `parameters`.\n\n    Arguments:\n        method: The HTTP method of the route.\n        path: The path template of the route.\n        **parameters: The parameters to format `path` with.\n\n    Returns:\n        The route constructed.\n    \"\"\"\n    return cls(method, path.format_map(parameters))\n</code></pre>"},{"location":"reference/http/#aoc.http.HTTPClient","title":"<code>HTTPClient</code>","text":"<p>Represents HTTP clients interacting with the Advent of Code servers.</p> Source code in <code>aoc/http.py</code> <pre><code>@define()\nclass HTTPClient:\n    \"\"\"Represents HTTP clients interacting with the Advent of Code servers.\"\"\"\n\n    token: str = field()\n    \"\"\"The token to use.\"\"\"\n\n    retries: int = field(default=DEFAULT_RETRIES)\n    \"\"\"The amount of retries to use.\"\"\"\n\n    async def request(\n        self,\n        method: str,\n        path: str,\n        payload: Optional[Payload] = None,\n        data: Optional[Parameters] = None,\n        parameters: Optional[Parameters] = None,\n        headers: Optional[Headers] = None,\n    ) -&gt; str:\n        \"\"\"Sends requests to the Advent of Code servers.\n\n        This method sends additional data in the request:\n\n        - `cookies`: The [`token`][aoc.http.HTTPClient.token] in the\n          [`TOKEN_COOKIE_NAME`][aoc.constants.TOKEN_COOKIE_NAME] cookie.\n\n        - `headers`: The [`HEADERS`][aoc.http.HEADERS].\n\n        Arguments:\n            method: The HTTP method to use.\n            path: The path to send the request to, relative to [`BASE_URL`][aoc.constants.BASE_URL].\n            payload: The payload to send (JSON).\n            data: The data to send.\n            parameters: The parameters to use.\n            headers: The headers to use.\n\n        Returns:\n            The response string.\n\n        Raises:\n            ClientError: All request attempts failed.\n        \"\"\"\n        attempts = self.retries + 1\n\n        error: Optional[ClientError] = None\n\n        session_cookies = {TOKEN_COOKIE_NAME: self.token}\n        session_headers = HEADERS\n        base_url = BASE_URL\n\n        while attempts:\n            try:\n                async with ClientSession(\n                    base_url=base_url, cookies=session_cookies, headers=session_headers\n                ) as session:\n                    response = await session.request(\n                        method,\n                        path,\n                        params=parameters,\n                        data=data,\n                        json=payload,\n                        headers=headers,\n                    )\n\n                    response.raise_for_status()\n\n            except ClientError as origin:\n                error = origin\n\n            else:\n                return await response.text()\n\n            attempts -= 1\n\n        if error:\n            raise error\n\n        return EMPTY  # pragma: never\n\n    async def request_route(\n        self,\n        route: Route,\n        payload: Optional[Payload] = None,\n        data: Optional[Parameters] = None,\n        parameters: Optional[Parameters] = None,\n        headers: Optional[Headers] = None,\n    ) -&gt; str:\n        \"\"\"Sends requests to the Advent of Code servers using routes.\n\n        ```python\n        response = await client.request_route(\n            route,\n            payload=payload,\n            data=data,\n            parameters=parameters,\n            headers=headers,\n        )\n        ```\n\n        is equivalent to:\n\n        ```python\n        response = await client.request(\n            route.method,\n            route.path,\n            payload=payload,\n            data=data,\n            parameters=parameters,\n            headers=headers,\n        )\n        ```\n\n        See [`request`][aoc.http.HTTPClient.request] for more information.\n\n        Arguments:\n            route: The route to send the request to.\n            payload: The payload to send (JSON).\n            data: The data to send.\n            parameters: The parameters to use.\n            headers: The headers to use.\n\n        Returns:\n            The response string.\n\n        Raises:\n            ClientError: All request attempts failed.\n        \"\"\"\n        return await self.request(\n            route.method,\n            route.path,\n            payload=payload,\n            data=data,\n            parameters=parameters,\n            headers=headers,\n        )\n\n    async def download_data(self, key: Key) -&gt; str:\n        \"\"\"Downloads the data for the problem for the given `key`.\n\n        Arguments:\n            key: The key to download the data for.\n\n        Returns:\n            The problem data downloaded.\n\n        Raises:\n            ClientError: All request attempts failed.\n        \"\"\"\n        route = Route.with_parameters(\n            GET, \"/{year}/day/{day}/input\", year=key.year.value, day=key.day.value\n        )\n\n        return await self.request_route(route)\n\n    async def submit_answer(self, key: Key, part: Part, answer: Any) -&gt; State:\n        \"\"\"Submits the `answer` for the problem `part` and the given `key`.\n\n        Arguments:\n            key: The key of the problem to submit the answer for.\n            part: The part of the problem to submit the answer for.\n            answer: The answer to submit.\n\n        Returns:\n            The state fetched from the response.\n\n        Raises:\n            ClientError: All request attempts failed.\n        \"\"\"\n        route = Route.with_parameters(\n            POST, \"/{year}/day/{day}/answer\", year=key.year.value, day=key.day.value\n        )\n\n        data = {PART: part.value, ANSWER: answer}\n\n        response = await self.request_route(route, data=data)\n\n        return State.match(response)\n</code></pre>"},{"location":"reference/http/#aoc.http.HTTPClient.token","title":"<code>token: str = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The token to use.</p>"},{"location":"reference/http/#aoc.http.HTTPClient.retries","title":"<code>retries: int = field(default=DEFAULT_RETRIES)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The amount of retries to use.</p>"},{"location":"reference/http/#aoc.http.HTTPClient.request","title":"<code>request(method: str, path: str, payload: Optional[Payload] = None, data: Optional[Parameters] = None, parameters: Optional[Parameters] = None, headers: Optional[Headers] = None) -&gt; str</code>  <code>async</code>","text":"<p>Sends requests to the Advent of Code servers.</p> <p>This method sends additional data in the request:</p> <ul> <li> <p><code>cookies</code>: The <code>token</code> in the   <code>TOKEN_COOKIE_NAME</code> cookie.</p> </li> <li> <p><code>headers</code>: The <code>HEADERS</code>.</p> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>The HTTP method to use.</p> required <code>path</code> <code>str</code> <p>The path to send the request to, relative to <code>BASE_URL</code>.</p> required <code>payload</code> <code>Optional[Payload]</code> <p>The payload to send (JSON).</p> <code>None</code> <code>data</code> <code>Optional[Parameters]</code> <p>The data to send.</p> <code>None</code> <code>parameters</code> <code>Optional[Parameters]</code> <p>The parameters to use.</p> <code>None</code> <code>headers</code> <code>Optional[Headers]</code> <p>The headers to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The response string.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>All request attempts failed.</p> Source code in <code>aoc/http.py</code> <pre><code>async def request(\n    self,\n    method: str,\n    path: str,\n    payload: Optional[Payload] = None,\n    data: Optional[Parameters] = None,\n    parameters: Optional[Parameters] = None,\n    headers: Optional[Headers] = None,\n) -&gt; str:\n    \"\"\"Sends requests to the Advent of Code servers.\n\n    This method sends additional data in the request:\n\n    - `cookies`: The [`token`][aoc.http.HTTPClient.token] in the\n      [`TOKEN_COOKIE_NAME`][aoc.constants.TOKEN_COOKIE_NAME] cookie.\n\n    - `headers`: The [`HEADERS`][aoc.http.HEADERS].\n\n    Arguments:\n        method: The HTTP method to use.\n        path: The path to send the request to, relative to [`BASE_URL`][aoc.constants.BASE_URL].\n        payload: The payload to send (JSON).\n        data: The data to send.\n        parameters: The parameters to use.\n        headers: The headers to use.\n\n    Returns:\n        The response string.\n\n    Raises:\n        ClientError: All request attempts failed.\n    \"\"\"\n    attempts = self.retries + 1\n\n    error: Optional[ClientError] = None\n\n    session_cookies = {TOKEN_COOKIE_NAME: self.token}\n    session_headers = HEADERS\n    base_url = BASE_URL\n\n    while attempts:\n        try:\n            async with ClientSession(\n                base_url=base_url, cookies=session_cookies, headers=session_headers\n            ) as session:\n                response = await session.request(\n                    method,\n                    path,\n                    params=parameters,\n                    data=data,\n                    json=payload,\n                    headers=headers,\n                )\n\n                response.raise_for_status()\n\n        except ClientError as origin:\n            error = origin\n\n        else:\n            return await response.text()\n\n        attempts -= 1\n\n    if error:\n        raise error\n\n    return EMPTY  # pragma: never\n</code></pre>"},{"location":"reference/http/#aoc.http.HTTPClient.request_route","title":"<code>request_route(route: Route, payload: Optional[Payload] = None, data: Optional[Parameters] = None, parameters: Optional[Parameters] = None, headers: Optional[Headers] = None) -&gt; str</code>  <code>async</code>","text":"<p>Sends requests to the Advent of Code servers using routes.</p> <pre><code>response = await client.request_route(\n    route,\n    payload=payload,\n    data=data,\n    parameters=parameters,\n    headers=headers,\n)\n</code></pre> <p>is equivalent to:</p> <pre><code>response = await client.request(\n    route.method,\n    route.path,\n    payload=payload,\n    data=data,\n    parameters=parameters,\n    headers=headers,\n)\n</code></pre> <p>See <code>request</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Route</code> <p>The route to send the request to.</p> required <code>payload</code> <code>Optional[Payload]</code> <p>The payload to send (JSON).</p> <code>None</code> <code>data</code> <code>Optional[Parameters]</code> <p>The data to send.</p> <code>None</code> <code>parameters</code> <code>Optional[Parameters]</code> <p>The parameters to use.</p> <code>None</code> <code>headers</code> <code>Optional[Headers]</code> <p>The headers to use.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The response string.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>All request attempts failed.</p> Source code in <code>aoc/http.py</code> <pre><code>async def request_route(\n    self,\n    route: Route,\n    payload: Optional[Payload] = None,\n    data: Optional[Parameters] = None,\n    parameters: Optional[Parameters] = None,\n    headers: Optional[Headers] = None,\n) -&gt; str:\n    \"\"\"Sends requests to the Advent of Code servers using routes.\n\n    ```python\n    response = await client.request_route(\n        route,\n        payload=payload,\n        data=data,\n        parameters=parameters,\n        headers=headers,\n    )\n    ```\n\n    is equivalent to:\n\n    ```python\n    response = await client.request(\n        route.method,\n        route.path,\n        payload=payload,\n        data=data,\n        parameters=parameters,\n        headers=headers,\n    )\n    ```\n\n    See [`request`][aoc.http.HTTPClient.request] for more information.\n\n    Arguments:\n        route: The route to send the request to.\n        payload: The payload to send (JSON).\n        data: The data to send.\n        parameters: The parameters to use.\n        headers: The headers to use.\n\n    Returns:\n        The response string.\n\n    Raises:\n        ClientError: All request attempts failed.\n    \"\"\"\n    return await self.request(\n        route.method,\n        route.path,\n        payload=payload,\n        data=data,\n        parameters=parameters,\n        headers=headers,\n    )\n</code></pre>"},{"location":"reference/http/#aoc.http.HTTPClient.download_data","title":"<code>download_data(key: Key) -&gt; str</code>  <code>async</code>","text":"<p>Downloads the data for the problem for the given <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Key</code> <p>The key to download the data for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The problem data downloaded.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>All request attempts failed.</p> Source code in <code>aoc/http.py</code> <pre><code>async def download_data(self, key: Key) -&gt; str:\n    \"\"\"Downloads the data for the problem for the given `key`.\n\n    Arguments:\n        key: The key to download the data for.\n\n    Returns:\n        The problem data downloaded.\n\n    Raises:\n        ClientError: All request attempts failed.\n    \"\"\"\n    route = Route.with_parameters(\n        GET, \"/{year}/day/{day}/input\", year=key.year.value, day=key.day.value\n    )\n\n    return await self.request_route(route)\n</code></pre>"},{"location":"reference/http/#aoc.http.HTTPClient.submit_answer","title":"<code>submit_answer(key: Key, part: Part, answer: Any) -&gt; State</code>  <code>async</code>","text":"<p>Submits the <code>answer</code> for the problem <code>part</code> and the given <code>key</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Key</code> <p>The key of the problem to submit the answer for.</p> required <code>part</code> <code>Part</code> <p>The part of the problem to submit the answer for.</p> required <code>answer</code> <code>Any</code> <p>The answer to submit.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The state fetched from the response.</p> <p>Raises:</p> Type Description <code>ClientError</code> <p>All request attempts failed.</p> Source code in <code>aoc/http.py</code> <pre><code>async def submit_answer(self, key: Key, part: Part, answer: Any) -&gt; State:\n    \"\"\"Submits the `answer` for the problem `part` and the given `key`.\n\n    Arguments:\n        key: The key of the problem to submit the answer for.\n        part: The part of the problem to submit the answer for.\n        answer: The answer to submit.\n\n    Returns:\n        The state fetched from the response.\n\n    Raises:\n        ClientError: All request attempts failed.\n    \"\"\"\n    route = Route.with_parameters(\n        POST, \"/{year}/day/{day}/answer\", year=key.year.value, day=key.day.value\n    )\n\n    data = {PART: part.value, ANSWER: answer}\n\n    response = await self.request_route(route, data=data)\n\n    return State.match(response)\n</code></pre>"},{"location":"reference/names/","title":"Names","text":""},{"location":"reference/names/#aoc.names.NAME_EXAMPLE","title":"<code>NAME_EXAMPLE = 'YearYYYYDayDD'</code>  <code>module-attribute</code>","text":"<p>The example of the name format.</p>"},{"location":"reference/names/#aoc.names.get_key_by_name","title":"<code>get_key_by_name(name: str) -&gt; Key</code>","text":"<p>Gets the key representing the problem by the name of the solution type.</p> Note <p>The <code>name</code> must match the format of <code>NAME_EXAMPLE</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the solution type.</p> required <p>Returns:</p> Type Description <code>Key</code> <p>The key representing the problem.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>The <code>name</code> does not match the expected format.</p> <code>ValueError</code> <p>The year or the day is not valid.</p> <code>InternalError</code> <p>The pattern was matched but <code>year</code> or <code>day</code> group is not set.</p> Source code in <code>aoc/names.py</code> <pre><code>def get_key_by_name(name: str) -&gt; Key:\n    \"\"\"Gets the key representing the problem by the name of the solution type.\n\n    Note:\n        The `name` must match the format of [`NAME_EXAMPLE`][aoc.names.NAME_EXAMPLE].\n\n    Arguments:\n        name: The name of the solution type.\n\n    Returns:\n        The key representing the problem.\n\n    Raises:\n        TypeError: The `name` does not match the expected format.\n        ValueError: The year or the day is not valid.\n        InternalError: The pattern was matched but `year` or `day` group is not set.\n    \"\"\"\n    match = NAME.match(name)\n\n    if match is None:\n        raise TypeError(invalid_name(name))\n\n    year_option = match.group(YEAR)\n\n    if year_option is None:\n        raise InternalError  # TODO: message?\n\n    year_value = int(year_option)\n\n    day_option = match.group(DAY)\n\n    if day_option is None:\n        raise InternalError  # TODO: message?\n\n    day_value = int(day_option)\n\n    try:\n        year = Year(year_value)\n\n    except ValueError as invalid_year:\n        raise TypeError(invalid_name_with_reason(name, invalid_year)) from invalid_year\n\n    try:\n        day = Day(day_value)\n\n    except ValueError as invalid_day:\n        raise TypeError(invalid_name_with_reason(name, invalid_day)) from invalid_day\n\n    return Key(year, day)\n</code></pre>"},{"location":"reference/names/#aoc.names.get_name_by_key","title":"<code>get_name_by_key(key: Key) -&gt; str</code>","text":"<p>The inverse of <code>get_key_by_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>Key</code> <p>The key to create the name for.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The name created.</p> Source code in <code>aoc/names.py</code> <pre><code>def get_name_by_key(key: Key) -&gt; str:\n    \"\"\"The inverse of [`get_key_by_name`][aoc.names.get_key_by_name].\n\n    Arguments:\n        key: The key to create the name for.\n\n    Returns:\n        The name created.\n    \"\"\"\n    return create_name(key.year.value, key.day.value)\n</code></pre>"},{"location":"reference/primitives/","title":"Primitives","text":""},{"location":"reference/primitives/#aoc.primitives.Year","title":"<code>Year</code>","text":"<p>The year of the problem (starts from <code>2015</code>).</p> Source code in <code>aoc/primitives.py</code> <pre><code>@final\n@frozen()\nclass Year:\n    \"\"\"The year of the problem (starts from `2015`).\"\"\"\n\n    value: int = field()\n    \"\"\"The contained value.\"\"\"\n\n    @value.validator\n    def check_value(self, attribute: Attribute[int], value: int) -&gt; None:\n        if value &lt; FIRST_YEAR:\n            raise ValueError(EXPECTED_YEAR)\n\n    def __str__(self) -&gt; str:\n        return year(self.value)\n</code></pre>"},{"location":"reference/primitives/#aoc.primitives.Year.value","title":"<code>value: int = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The contained value.</p>"},{"location":"reference/primitives/#aoc.primitives.Day","title":"<code>Day</code>","text":"<p>The day of the problem (in <code>[1, 25]</code> range).</p> Source code in <code>aoc/primitives.py</code> <pre><code>@final\n@frozen()\nclass Day:\n    \"\"\"The day of the problem (in `[1, 25]` range).\"\"\"\n\n    value: int = field()\n    \"\"\"The contained value.\"\"\"\n\n    @value.validator\n    def check_value(self, attribute: Attribute[int], value: int) -&gt; None:\n        if value &lt; FIRST_DAY:\n            raise ValueError(EXPECTED_DAY)\n\n        if value &gt; LAST_DAY:\n            raise ValueError(EXPECTED_DAY)\n\n    def __str__(self) -&gt; str:\n        return day(self.value)\n</code></pre>"},{"location":"reference/primitives/#aoc.primitives.Day.value","title":"<code>value: int = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The contained value.</p>"},{"location":"reference/primitives/#aoc.primitives.Key","title":"<code>Key</code>","text":"<p>The key of the problem.</p> <p>This is essentially the <code>(year, day)</code> combination of <code>Year</code> and <code>Day</code>.</p> Source code in <code>aoc/primitives.py</code> <pre><code>@final\n@frozen()\nclass Key:\n    \"\"\"The key of the problem.\n\n    This is essentially the `(year, day)` combination of\n    [`Year`][aoc.primitives.Year] and [`Day`][aoc.primitives.Day].\n    \"\"\"\n\n    year: Year\n    \"\"\"The year of the problem.\"\"\"\n\n    day: Day\n    \"\"\"The day of the problem.\"\"\"\n\n    def __str__(self) -&gt; str:\n        return key(self.year, self.day)\n</code></pre>"},{"location":"reference/primitives/#aoc.primitives.Key.year","title":"<code>year: Year</code>  <code>instance-attribute</code>","text":"<p>The year of the problem.</p>"},{"location":"reference/primitives/#aoc.primitives.Key.day","title":"<code>day: Day</code>  <code>instance-attribute</code>","text":"<p>The day of the problem.</p>"},{"location":"reference/primitives/#aoc.primitives.Part","title":"<code>Part</code>","text":"<p>             Bases: <code>Enum</code></p> <p>The part of the problem.</p> Source code in <code>aoc/primitives.py</code> <pre><code>class Part(Enum):\n    \"\"\"The part of the problem.\"\"\"\n\n    ONE = 1\n    \"\"\"Part one of the problem.\"\"\"\n\n    TWO = 2\n    \"\"\"Part two of the problem.\"\"\"\n\n    ONLY = ONE\n    \"\"\"The only part of the problem.\"\"\"\n</code></pre>"},{"location":"reference/primitives/#aoc.primitives.Part.ONE","title":"<code>ONE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Part one of the problem.</p>"},{"location":"reference/primitives/#aoc.primitives.Part.TWO","title":"<code>TWO = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Part two of the problem.</p>"},{"location":"reference/primitives/#aoc.primitives.Part.ONLY","title":"<code>ONLY = ONE</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The only part of the problem.</p>"},{"location":"reference/runners/","title":"Runners","text":""},{"location":"reference/runners/#aoc.runners.Results","title":"<code>Results</code>","text":"<p>Represents the results of running modules.</p> Source code in <code>aoc/runners.py</code> <pre><code>@final\n@frozen()\nclass Results:\n    \"\"\"Represents the results of running modules.\"\"\"\n\n    results: Dict[Key, AnyResult]\n    \"\"\"The results of running [`Solution`][aoc.solutions.Solution] instances.\"\"\"\n\n    final_results: Dict[Key, AnyFinalResult]\n    \"\"\"The results of running [`FinalSolution`][aoc.solutions.FinalSolution] instances.\"\"\"\n</code></pre>"},{"location":"reference/runners/#aoc.runners.Results.results","title":"<code>results: Dict[Key, AnyResult]</code>  <code>instance-attribute</code>","text":"<p>The results of running <code>Solution</code> instances.</p>"},{"location":"reference/runners/#aoc.runners.Results.final_results","title":"<code>final_results: Dict[Key, AnyFinalResult]</code>  <code>instance-attribute</code>","text":"<p>The results of running <code>FinalSolution</code> instances.</p>"},{"location":"reference/runners/#aoc.runners.Runner","title":"<code>Runner</code>","text":"<p>Represents runners for python paths containing modules.</p> Source code in <code>aoc/runners.py</code> <pre><code>@frozen()\nclass Runner:\n    \"\"\"Represents runners for python paths containing modules.\"\"\"\n\n    def run_path(self, path: Path, data_path: Path = DATA_PATH) -&gt; Results:\n        \"\"\"Runs the module from the `path` and returns the results.\n\n        Arguments:\n            path: The path to the module.\n            data_path: The path to the data directory.\n\n        Returns:\n            The results of running the module.\n\n        Raises:\n            AnyError: Any error that occurs while running.\n        \"\"\"\n        namespace = run_python_path(str(path))\n\n        solutions = SOLUTIONS\n        final_solutions = FINAL_SOLUTIONS\n\n        results = {}\n        final_results = {}\n\n        for name in namespace:\n            try:\n                key = get_key_by_name(name)\n\n            except TypeError:\n                pass\n\n            else:\n                if key in solutions:\n                    solution = solutions[key]()\n\n                    data = load_data(key, data_path)\n\n                    results[key] = solution.execute(data)\n\n                if key in final_solutions:\n                    final_solution = final_solutions[key]()\n\n                    data = load_data(key, data_path)\n\n                    final_results[key] = final_solution.execute(data)\n\n        return Results(results, final_results)\n</code></pre>"},{"location":"reference/runners/#aoc.runners.Runner.run_path","title":"<code>run_path(path: Path, data_path: Path = DATA_PATH) -&gt; Results</code>","text":"<p>Runs the module from the <code>path</code> and returns the results.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the module.</p> required <code>data_path</code> <code>Path</code> <p>The path to the data directory.</p> <code>DATA_PATH</code> <p>Returns:</p> Type Description <code>Results</code> <p>The results of running the module.</p> <p>Raises:</p> Type Description <code>AnyError</code> <p>Any error that occurs while running.</p> Source code in <code>aoc/runners.py</code> <pre><code>def run_path(self, path: Path, data_path: Path = DATA_PATH) -&gt; Results:\n    \"\"\"Runs the module from the `path` and returns the results.\n\n    Arguments:\n        path: The path to the module.\n        data_path: The path to the data directory.\n\n    Returns:\n        The results of running the module.\n\n    Raises:\n        AnyError: Any error that occurs while running.\n    \"\"\"\n    namespace = run_python_path(str(path))\n\n    solutions = SOLUTIONS\n    final_solutions = FINAL_SOLUTIONS\n\n    results = {}\n    final_results = {}\n\n    for name in namespace:\n        try:\n            key = get_key_by_name(name)\n\n        except TypeError:\n            pass\n\n        else:\n            if key in solutions:\n                solution = solutions[key]()\n\n                data = load_data(key, data_path)\n\n                results[key] = solution.execute(data)\n\n            if key in final_solutions:\n                final_solution = final_solutions[key]()\n\n                data = load_data(key, data_path)\n\n                final_results[key] = final_solution.execute(data)\n\n    return Results(results, final_results)\n</code></pre>"},{"location":"reference/runners/#aoc.runners.run_path","title":"<code>run_path(path: Path, data_path: Path = DATA_PATH, runner_type: Type[Runner] = Runner) -&gt; Results</code>","text":"<p>Runs the module with the given <code>name</code> and returns the results.</p> <p>This is equivalent to:</p> <pre><code>runner_type().run_path(path, data_path)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the module.</p> required <code>data_path</code> <code>Path</code> <p>The path to the data directory.</p> <code>DATA_PATH</code> <code>runner_type</code> <code>Type[Runner]</code> <p>The runner type to use.</p> <code>Runner</code> <p>Returns:</p> Type Description <code>Results</code> <p>The results of running the module.</p> <p>Raises:</p> Type Description <code>AnyError</code> <p>Any error that occurs while running.</p> Source code in <code>aoc/runners.py</code> <pre><code>def run_path(\n    path: Path, data_path: Path = DATA_PATH, runner_type: Type[Runner] = Runner\n) -&gt; Results:\n    \"\"\"Runs the module with the given `name` and returns the results.\n\n    This is equivalent to:\n\n    ```python\n    runner_type().run_path(path, data_path)\n    ```\n\n    Arguments:\n        path: The path to the module.\n        data_path: The path to the data directory.\n        runner_type: The runner type to use.\n\n    Returns:\n        The results of running the module.\n\n    Raises:\n        AnyError: Any error that occurs while running.\n    \"\"\"\n    return runner_type().run_path(path, data_path)\n</code></pre>"},{"location":"reference/solutions/","title":"Solutions","text":""},{"location":"reference/solutions/#aoc.solutions.Result","title":"<code>Result</code>","text":"<p>             Bases: <code>Generic[T, U]</code></p> <p>Represents the result of the problem solution.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@final\n@frozen()\nclass Result(Generic[T, U]):\n    \"\"\"Represents the result of the problem solution.\"\"\"\n\n    answer_one: T\n    \"\"\"The answer to the part one of the problem.\"\"\"\n\n    answer_two: U\n    \"\"\"The answer to the part two of the problem.\"\"\"\n\n    parse_time: Elapsed\n    \"\"\"The time it took to parse the data.\"\"\"\n\n    solve_one_time: Elapsed\n    \"\"\"The time it took to solve part one.\"\"\"\n\n    solve_two_time: Elapsed\n    \"\"\"The time it took to solve part two.\"\"\"\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.Result.answer_one","title":"<code>answer_one: T</code>  <code>instance-attribute</code>","text":"<p>The answer to the part one of the problem.</p>"},{"location":"reference/solutions/#aoc.solutions.Result.answer_two","title":"<code>answer_two: U</code>  <code>instance-attribute</code>","text":"<p>The answer to the part two of the problem.</p>"},{"location":"reference/solutions/#aoc.solutions.Result.parse_time","title":"<code>parse_time: Elapsed</code>  <code>instance-attribute</code>","text":"<p>The time it took to parse the data.</p>"},{"location":"reference/solutions/#aoc.solutions.Result.solve_one_time","title":"<code>solve_one_time: Elapsed</code>  <code>instance-attribute</code>","text":"<p>The time it took to solve part one.</p>"},{"location":"reference/solutions/#aoc.solutions.Result.solve_two_time","title":"<code>solve_two_time: Elapsed</code>  <code>instance-attribute</code>","text":"<p>The time it took to solve part two.</p>"},{"location":"reference/solutions/#aoc.solutions.Solution","title":"<code>Solution</code>","text":"<p>             Bases: <code>Protocol[I, T, U]</code></p> <p>Represents problem solutions.</p> Source code in <code>aoc/solutions.py</code> <pre><code>class Solution(Protocol[I, T, U]):\n    \"\"\"Represents problem solutions.\"\"\"\n\n    def __init_subclass__(cls, **keywords: Any) -&gt; None:\n        super().__init_subclass__(**keywords)\n\n        SOLUTIONS[get_key_by_name(get_name(cls))] = cls\n\n    @required\n    def parse(self, data: str) -&gt; I:\n        \"\"\"Parses the data into the input type.\n\n        Arguments:\n            data: The data to parse.\n\n        Returns:\n            The input of the problem.\n        \"\"\"\n        raise NotImplementedError(MUST_IMPLEMENT_PARSE)\n\n    @required\n    def solve_one(self, input: I) -&gt; T:\n        \"\"\"Solves part one of the problem.\n\n        Arguments:\n            input: The input of the problem, as returned by [`parse`][aoc.solutions.Solution.parse].\n\n        Returns:\n            The answer to part one of the problem.\n        \"\"\"\n        raise NotImplementedError(MUST_IMPLEMENT_SOLVE_ONE)\n\n    @required\n    def solve_two(self, input: I) -&gt; U:\n        \"\"\"Solves part two of the problem.\n\n        Arguments:\n            input: The input of the problem, as returned by [`parse`][aoc.solutions.Solution.parse].\n\n        Returns:\n            The answer to part two of the problem.\n        \"\"\"\n        raise NotImplementedError(MUST_IMPLEMENT_SOLVE_TWO)\n\n    def execute(self, data: str) -&gt; Result[T, U]:\n        \"\"\"Executes the problem solution on the given data.\n\n        Arguments:\n            data: The data to parse and solve the problem for.\n\n        Returns:\n            The result of the solution.\n        \"\"\"\n        parse = self.parse\n        solve_one = self.solve_one\n        solve_two = self.solve_two\n\n        timer = now()\n\n        input = parse(data)\n\n        parse_time = timer.elapsed()\n\n        timer = timer.reset()\n\n        answer_one = solve_one(input)\n\n        solve_one_time = timer.elapsed()\n\n        timer = timer.reset()\n\n        answer_two = solve_two(input)\n\n        solve_two_time = timer.elapsed()\n\n        return Result(answer_one, answer_two, parse_time, solve_one_time, solve_two_time)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.Solution.parse","title":"<code>parse(data: str) -&gt; I</code>  <code>abstractmethod</code>","text":"<p>Parses the data into the input type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to parse.</p> required <p>Returns:</p> Type Description <code>I</code> <p>The input of the problem.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@required\ndef parse(self, data: str) -&gt; I:\n    \"\"\"Parses the data into the input type.\n\n    Arguments:\n        data: The data to parse.\n\n    Returns:\n        The input of the problem.\n    \"\"\"\n    raise NotImplementedError(MUST_IMPLEMENT_PARSE)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.Solution.solve_one","title":"<code>solve_one(input: I) -&gt; T</code>  <code>abstractmethod</code>","text":"<p>Solves part one of the problem.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>I</code> <p>The input of the problem, as returned by <code>parse</code>.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The answer to part one of the problem.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@required\ndef solve_one(self, input: I) -&gt; T:\n    \"\"\"Solves part one of the problem.\n\n    Arguments:\n        input: The input of the problem, as returned by [`parse`][aoc.solutions.Solution.parse].\n\n    Returns:\n        The answer to part one of the problem.\n    \"\"\"\n    raise NotImplementedError(MUST_IMPLEMENT_SOLVE_ONE)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.Solution.solve_two","title":"<code>solve_two(input: I) -&gt; U</code>  <code>abstractmethod</code>","text":"<p>Solves part two of the problem.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>I</code> <p>The input of the problem, as returned by <code>parse</code>.</p> required <p>Returns:</p> Type Description <code>U</code> <p>The answer to part two of the problem.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@required\ndef solve_two(self, input: I) -&gt; U:\n    \"\"\"Solves part two of the problem.\n\n    Arguments:\n        input: The input of the problem, as returned by [`parse`][aoc.solutions.Solution.parse].\n\n    Returns:\n        The answer to part two of the problem.\n    \"\"\"\n    raise NotImplementedError(MUST_IMPLEMENT_SOLVE_TWO)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.Solution.execute","title":"<code>execute(data: str) -&gt; Result[T, U]</code>","text":"<p>Executes the problem solution on the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to parse and solve the problem for.</p> required <p>Returns:</p> Type Description <code>Result[T, U]</code> <p>The result of the solution.</p> Source code in <code>aoc/solutions.py</code> <pre><code>def execute(self, data: str) -&gt; Result[T, U]:\n    \"\"\"Executes the problem solution on the given data.\n\n    Arguments:\n        data: The data to parse and solve the problem for.\n\n    Returns:\n        The result of the solution.\n    \"\"\"\n    parse = self.parse\n    solve_one = self.solve_one\n    solve_two = self.solve_two\n\n    timer = now()\n\n    input = parse(data)\n\n    parse_time = timer.elapsed()\n\n    timer = timer.reset()\n\n    answer_one = solve_one(input)\n\n    solve_one_time = timer.elapsed()\n\n    timer = timer.reset()\n\n    answer_two = solve_two(input)\n\n    solve_two_time = timer.elapsed()\n\n    return Result(answer_one, answer_two, parse_time, solve_one_time, solve_two_time)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.FinalResult","title":"<code>FinalResult</code>","text":"<p>             Bases: <code>Generic[T]</code></p> <p>Represents the result of the final problem solution.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@final\n@frozen()\nclass FinalResult(Generic[T]):\n    \"\"\"Represents the result of the final problem solution.\"\"\"\n\n    answer: T\n    \"\"\"The answer to the problem.\"\"\"\n\n    parse_time: Elapsed\n    \"\"\"The time it took to parse the data.\"\"\"\n\n    solve_time: Elapsed\n    \"\"\"The time it took to solve the problem.\"\"\"\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.FinalResult.answer","title":"<code>answer: T</code>  <code>instance-attribute</code>","text":"<p>The answer to the problem.</p>"},{"location":"reference/solutions/#aoc.solutions.FinalResult.parse_time","title":"<code>parse_time: Elapsed</code>  <code>instance-attribute</code>","text":"<p>The time it took to parse the data.</p>"},{"location":"reference/solutions/#aoc.solutions.FinalResult.solve_time","title":"<code>solve_time: Elapsed</code>  <code>instance-attribute</code>","text":"<p>The time it took to solve the problem.</p>"},{"location":"reference/solutions/#aoc.solutions.FinalSolution","title":"<code>FinalSolution</code>","text":"<p>             Bases: <code>Protocol[I, T]</code></p> <p>Represents final problem solutions.</p> Source code in <code>aoc/solutions.py</code> <pre><code>class FinalSolution(Protocol[I, T]):\n    \"\"\"Represents final problem solutions.\"\"\"\n\n    def __init_subclass__(cls, **keywords: Any) -&gt; None:\n        super().__init_subclass__(**keywords)\n\n        FINAL_SOLUTIONS[get_key_by_name(get_name(cls))] = cls\n\n    @required\n    def parse(self, data: str) -&gt; I:\n        \"\"\"Parses the data into the input type.\n\n        Arguments:\n            data: The data to parse.\n\n        Returns:\n            The input of the problem.\n        \"\"\"\n        raise NotImplementedError(MUST_IMPLEMENT_PARSE)\n\n    @required\n    def solve(self, input: I) -&gt; T:\n        \"\"\"Solves the problem.\n\n        Arguments:\n            input: The input of the problem, as returned by\n                [`parse`][aoc.solutions.FinalSolution.parse].\n\n        Returns:\n            The answer to the problem.\n        \"\"\"\n        raise NotImplementedError(MUST_IMPLEMENT_SOLVE)\n\n    def execute(self, data: str) -&gt; FinalResult[T]:\n        \"\"\"Executes the problem solution on the given data.\n\n        Arguments:\n            data: The data to parse and solve the problem for.\n\n        Returns:\n            The result of the solution.\n        \"\"\"\n        parse = self.parse\n        solve = self.solve\n\n        timer = now()\n\n        input = parse(data)\n\n        parse_time = timer.elapsed()\n\n        timer = timer.reset()\n\n        answer = solve(input)\n\n        solve_time = timer.elapsed()\n\n        return FinalResult(answer, parse_time, solve_time)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.FinalSolution.parse","title":"<code>parse(data: str) -&gt; I</code>  <code>abstractmethod</code>","text":"<p>Parses the data into the input type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to parse.</p> required <p>Returns:</p> Type Description <code>I</code> <p>The input of the problem.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@required\ndef parse(self, data: str) -&gt; I:\n    \"\"\"Parses the data into the input type.\n\n    Arguments:\n        data: The data to parse.\n\n    Returns:\n        The input of the problem.\n    \"\"\"\n    raise NotImplementedError(MUST_IMPLEMENT_PARSE)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.FinalSolution.solve","title":"<code>solve(input: I) -&gt; T</code>  <code>abstractmethod</code>","text":"<p>Solves the problem.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>I</code> <p>The input of the problem, as returned by <code>parse</code>.</p> required <p>Returns:</p> Type Description <code>T</code> <p>The answer to the problem.</p> Source code in <code>aoc/solutions.py</code> <pre><code>@required\ndef solve(self, input: I) -&gt; T:\n    \"\"\"Solves the problem.\n\n    Arguments:\n        input: The input of the problem, as returned by\n            [`parse`][aoc.solutions.FinalSolution.parse].\n\n    Returns:\n        The answer to the problem.\n    \"\"\"\n    raise NotImplementedError(MUST_IMPLEMENT_SOLVE)\n</code></pre>"},{"location":"reference/solutions/#aoc.solutions.FinalSolution.execute","title":"<code>execute(data: str) -&gt; FinalResult[T]</code>","text":"<p>Executes the problem solution on the given data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>The data to parse and solve the problem for.</p> required <p>Returns:</p> Type Description <code>FinalResult[T]</code> <p>The result of the solution.</p> Source code in <code>aoc/solutions.py</code> <pre><code>def execute(self, data: str) -&gt; FinalResult[T]:\n    \"\"\"Executes the problem solution on the given data.\n\n    Arguments:\n        data: The data to parse and solve the problem for.\n\n    Returns:\n        The result of the solution.\n    \"\"\"\n    parse = self.parse\n    solve = self.solve\n\n    timer = now()\n\n    input = parse(data)\n\n    parse_time = timer.elapsed()\n\n    timer = timer.reset()\n\n    answer = solve(input)\n\n    solve_time = timer.elapsed()\n\n    return FinalResult(answer, parse_time, solve_time)\n</code></pre>"},{"location":"reference/states/","title":"States","text":""},{"location":"reference/states/#aoc.states.State","title":"<code>State</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Represents the state of answers.</p> Source code in <code>aoc/states.py</code> <pre><code>class State(Enum):\n    \"\"\"Represents the state of answers.\"\"\"\n\n    CORRECT = auto()\n    \"\"\"The answer is correct.\"\"\"\n\n    SOLVED = auto()\n    \"\"\"The problem part was already solved.\"\"\"\n\n    LOW = auto()\n    \"\"\"The answer is too low.\"\"\"\n\n    HIGH = auto()\n    \"\"\"The answer is too high.\"\"\"\n\n    WRONG = auto()\n    \"\"\"The answer is wrong.\"\"\"\n\n    TIMEOUT = auto()\n    \"\"\"The answer was submitted too recently (timeout).\"\"\"\n\n    UNKNOWN = auto()\n    \"\"\"The answer state is unknown.\"\"\"\n\n    @classmethod\n    def match(cls, string: str) -&gt; State:\n        \"\"\"Matches the given `string` and returns the corresponding state.\n\n        Arguments:\n            string: The string to match.\n\n        Returns:\n            The corresponding state ([`UNKNOWN`][aoc.states.State.UNKNOWN] if no match is found).\n        \"\"\"\n        string = case_fold(string)\n\n        if CORRECT_MATCH in string:\n            return cls.CORRECT\n\n        if SOLVED_MATCH in string:\n            return cls.SOLVED\n\n        if LOW_MATCH in string:\n            return cls.LOW\n\n        if HIGH_MATCH in string:\n            return cls.HIGH\n\n        if WRONG_MATCH in string:\n            return cls.WRONG\n\n        if TIMEOUT_MATCH in string:\n            return cls.TIMEOUT\n\n        return cls.UNKNOWN\n\n    @property\n    def message(self) -&gt; str:\n        \"\"\"Returns the message for this state.\n\n        Returns:\n            The message for this state.\n        \"\"\"\n        cls = type(self)\n\n        if self is cls.CORRECT:\n            return CORRECT_MESSAGE\n\n        if self is cls.SOLVED:\n            return SOLVED_MESSAGE\n\n        if self is cls.LOW:\n            return LOW_MESSAGE\n\n        if self is cls.HIGH:\n            return HIGH_MESSAGE\n\n        if self is cls.WRONG:\n            return WRONG_MESSAGE\n\n        if self is cls.TIMEOUT:\n            return TIMEOUT_MESSAGE\n\n        if self is cls.UNKNOWN:\n            return UNKNOWN_MESSAGE\n\n        assert_never(self)  # pragma: never\n</code></pre>"},{"location":"reference/states/#aoc.states.State.CORRECT","title":"<code>CORRECT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer is correct.</p>"},{"location":"reference/states/#aoc.states.State.SOLVED","title":"<code>SOLVED = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The problem part was already solved.</p>"},{"location":"reference/states/#aoc.states.State.LOW","title":"<code>LOW = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer is too low.</p>"},{"location":"reference/states/#aoc.states.State.HIGH","title":"<code>HIGH = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer is too high.</p>"},{"location":"reference/states/#aoc.states.State.WRONG","title":"<code>WRONG = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer is wrong.</p>"},{"location":"reference/states/#aoc.states.State.TIMEOUT","title":"<code>TIMEOUT = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer was submitted too recently (timeout).</p>"},{"location":"reference/states/#aoc.states.State.UNKNOWN","title":"<code>UNKNOWN = auto()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The answer state is unknown.</p>"},{"location":"reference/states/#aoc.states.State.message","title":"<code>message: str</code>  <code>property</code>","text":"<p>Returns the message for this state.</p> <p>Returns:</p> Type Description <code>str</code> <p>The message for this state.</p>"},{"location":"reference/states/#aoc.states.State.match","title":"<code>match(string: str) -&gt; State</code>  <code>classmethod</code>","text":"<p>Matches the given <code>string</code> and returns the corresponding state.</p> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to match.</p> required <p>Returns:</p> Type Description <code>State</code> <p>The corresponding state (<code>UNKNOWN</code> if no match is found).</p> Source code in <code>aoc/states.py</code> <pre><code>@classmethod\ndef match(cls, string: str) -&gt; State:\n    \"\"\"Matches the given `string` and returns the corresponding state.\n\n    Arguments:\n        string: The string to match.\n\n    Returns:\n        The corresponding state ([`UNKNOWN`][aoc.states.State.UNKNOWN] if no match is found).\n    \"\"\"\n    string = case_fold(string)\n\n    if CORRECT_MATCH in string:\n        return cls.CORRECT\n\n    if SOLVED_MATCH in string:\n        return cls.SOLVED\n\n    if LOW_MATCH in string:\n        return cls.LOW\n\n    if HIGH_MATCH in string:\n        return cls.HIGH\n\n    if WRONG_MATCH in string:\n        return cls.WRONG\n\n    if TIMEOUT_MATCH in string:\n        return cls.TIMEOUT\n\n    return cls.UNKNOWN\n</code></pre>"},{"location":"reference/time/","title":"Time","text":""},{"location":"reference/time/#aoc.time.AOC_TIMEZONE_NAME","title":"<code>AOC_TIMEZONE_NAME = 'EST'</code>  <code>module-attribute</code>","text":"<p>The Advent of Code timezone name.</p>"},{"location":"reference/time/#aoc.time.AOC_TIMEZONE","title":"<code>AOC_TIMEZONE = timezone(AOC_TIMEZONE_NAME)</code>  <code>module-attribute</code>","text":"<p>The Advent of Code timezone.</p>"},{"location":"reference/time/#aoc.time.aoc_today","title":"<code>aoc_today() -&gt; Date</code>","text":"<p>Returns the current date in the <code>AOC_TIMEZONE</code>.</p> Source code in <code>aoc/time.py</code> <pre><code>def aoc_today() -&gt; Date:\n    \"\"\"Returns the current date in the [`AOC_TIMEZONE`][aoc.time.AOC_TIMEZONE].\"\"\"\n    return today(AOC_TIMEZONE)\n</code></pre>"},{"location":"reference/time/#aoc.time.get_key_for_date","title":"<code>get_key_for_date(date: Date) -&gt; Key</code>","text":"<p>Returns the key for the given <code>date</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The <code>date</code> does not represent the Advent of Code day.</p> Source code in <code>aoc/time.py</code> <pre><code>def get_key_for_date(date: Date) -&gt; Key:\n    \"\"\"Returns the key for the given `date`.\n\n    Raises:\n        ValueError: The `date` does not represent the Advent of Code day.\n    \"\"\"\n    return Key(Year(date.year), Day(date.day))\n</code></pre>"},{"location":"reference/timers/","title":"Timers","text":""},{"location":"reference/timers/#aoc.timers.Clock","title":"<code>Clock = Nullary[int]</code>  <code>module-attribute</code>","text":"<p>The type representing clocks which return time in nanoseconds.</p>"},{"location":"reference/timers/#aoc.timers.Elapsed","title":"<code>Elapsed</code>","text":"<p>Represents elapsed time, in nanoseconds and human-readable format.</p> Source code in <code>aoc/timers.py</code> <pre><code>@final\n@frozen()\nclass Elapsed:\n    \"\"\"Represents elapsed time, in nanoseconds and human-readable format.\"\"\"\n\n    nanoseconds: int = field()\n    \"\"\"The time elapsed, in nanoseconds.\"\"\"\n\n    rounding: int = field(default=DEFAULT_ROUNDING)\n    \"\"\"The rounding to use when converting to human-readable format.\"\"\"\n\n    string: str = field(init=False)\n    \"\"\"The time elapsed, in human-readable format.\"\"\"\n\n    @string.default\n    def default_string(self) -&gt; str:\n        nanoseconds = self.nanoseconds\n\n        for name, factor in FACTORS:\n            if nanoseconds &gt; factor:\n                return str(round(nanoseconds / factor, self.rounding)) + name\n\n        return INSTANT\n\n    def __str__(self) -&gt; str:\n        return self.string\n</code></pre>"},{"location":"reference/timers/#aoc.timers.Elapsed.nanoseconds","title":"<code>nanoseconds: int = field()</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time elapsed, in nanoseconds.</p>"},{"location":"reference/timers/#aoc.timers.Elapsed.rounding","title":"<code>rounding: int = field(default=DEFAULT_ROUNDING)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The rounding to use when converting to human-readable format.</p>"},{"location":"reference/timers/#aoc.timers.Elapsed.string","title":"<code>string: str = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The time elapsed, in human-readable format.</p>"},{"location":"reference/timers/#aoc.timers.Timer","title":"<code>Timer</code>","text":"<p>Represents timers.</p> Source code in <code>aoc/timers.py</code> <pre><code>@final\n@frozen()\nclass Timer:\n    \"\"\"Represents timers.\"\"\"\n\n    clock: Clock = field(default=default_clock)\n    \"\"\"The clock to use.\"\"\"\n\n    created: int = field(init=False)\n    \"\"\"The creation time of the timer.\"\"\"\n\n    @created.default\n    def default_created(self) -&gt; int:\n        return self.clock()\n\n    def elapsed(self, rounding: int = DEFAULT_ROUNDING) -&gt; Elapsed:\n        \"\"\"Returns the time elapsed since the creation of this timer.\n\n        Returns:\n            The time elapsed since the creation of this timer.\n        \"\"\"\n        return Elapsed(self.clock() - self.created, rounding)\n\n    def reset(self) -&gt; Self:\n        \"\"\"Creates and returns a new timer of the same type with the same clock.\n\n        Returns:\n            The timer created.\n        \"\"\"\n        return type(self)(self.clock)\n</code></pre>"},{"location":"reference/timers/#aoc.timers.Timer.clock","title":"<code>clock: Clock = field(default=default_clock)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The clock to use.</p>"},{"location":"reference/timers/#aoc.timers.Timer.created","title":"<code>created: int = field(init=False)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>The creation time of the timer.</p>"},{"location":"reference/timers/#aoc.timers.Timer.elapsed","title":"<code>elapsed(rounding: int = DEFAULT_ROUNDING) -&gt; Elapsed</code>","text":"<p>Returns the time elapsed since the creation of this timer.</p> <p>Returns:</p> Type Description <code>Elapsed</code> <p>The time elapsed since the creation of this timer.</p> Source code in <code>aoc/timers.py</code> <pre><code>def elapsed(self, rounding: int = DEFAULT_ROUNDING) -&gt; Elapsed:\n    \"\"\"Returns the time elapsed since the creation of this timer.\n\n    Returns:\n        The time elapsed since the creation of this timer.\n    \"\"\"\n    return Elapsed(self.clock() - self.created, rounding)\n</code></pre>"},{"location":"reference/timers/#aoc.timers.Timer.reset","title":"<code>reset() -&gt; Self</code>","text":"<p>Creates and returns a new timer of the same type with the same clock.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The timer created.</p> Source code in <code>aoc/timers.py</code> <pre><code>def reset(self) -&gt; Self:\n    \"\"\"Creates and returns a new timer of the same type with the same clock.\n\n    Returns:\n        The timer created.\n    \"\"\"\n    return type(self)(self.clock)\n</code></pre>"},{"location":"reference/timers/#aoc.timers.now","title":"<code>now(clock: Clock = default_clock) -&gt; Timer</code>","text":"<p>Creates a new timer with the given (or default) clock.</p> <p>Parameters:</p> Name Type Description Default <code>clock</code> <code>Clock</code> <p>The clock to use.</p> <code>perf_counter_ns</code> <p>Returns:</p> Type Description <code>Timer</code> <p>The timer created.</p> Source code in <code>aoc/timers.py</code> <pre><code>def now(clock: Clock = default_clock) -&gt; Timer:\n    \"\"\"Creates a new timer with the given (or default) clock.\n\n    Arguments:\n        clock: The clock to use.\n\n    Returns:\n        The timer created.\n    \"\"\"\n    return Timer(clock)\n</code></pre>"},{"location":"reference/tokens/","title":"Tokens","text":""},{"location":"reference/tokens/#aoc.tokens.load_token","title":"<code>load_token(path: Path = TOKEN_PATH, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS) -&gt; str</code>","text":"<p>Loads the token from the given <code>path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the token file.</p> <code>TOKEN_PATH</code> <code>encoding</code> <code>str</code> <p>The encoding to use.</p> <code>DEFAULT_ENCODING</code> <code>errors</code> <code>str</code> <p>The error handling of the encoding to use.</p> <code>DEFAULT_ERRORS</code> <p>Returns:</p> Type Description <code>str</code> <p>The loaded token.</p> <p>Raises:</p> Type Description <code>TokenNotFound</code> <p><code>OSError</code> occured.</p> Source code in <code>aoc/tokens.py</code> <pre><code>def load_token(\n    path: Path = TOKEN_PATH, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS\n) -&gt; str:\n    \"\"\"Loads the token from the given `path`.\n\n    Arguments:\n        path: The path to the token file.\n        encoding: The encoding to use.\n        errors: The error handling of the encoding to use.\n\n    Returns:\n        The loaded token.\n\n    Raises:\n        TokenNotFound: [`OSError`][OSError] occured.\"\"\"\n    try:\n        return path.read_text(encoding, errors).strip()\n\n    except OSError as origin:\n        raise TokenNotFound(path) from origin\n</code></pre>"},{"location":"reference/tokens/#aoc.tokens.dump_token","title":"<code>dump_token(token: str, path: Path = TOKEN_PATH, encoding: str = DEFAULT_ENCODING, errors: str = DEFAULT_ERRORS) -&gt; None</code>","text":"<p>Dumps the <code>token</code> to the given <code>path</code>.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>The token to dump.</p> required <code>path</code> <code>Path</code> <p>The path to the token file.</p> <code>TOKEN_PATH</code> <code>encoding</code> <code>str</code> <p>The encoding to use.</p> <code>DEFAULT_ENCODING</code> <code>errors</code> <code>str</code> <p>The error handling of the encoding to use.</p> <code>DEFAULT_ERRORS</code> Source code in <code>aoc/tokens.py</code> <pre><code>def dump_token(\n    token: str,\n    path: Path = TOKEN_PATH,\n    encoding: str = DEFAULT_ENCODING,\n    errors: str = DEFAULT_ERRORS,\n) -&gt; None:\n    \"\"\"Dumps the `token` to the given `path`.\n\n    Arguments:\n        token: The token to dump.\n        path: The path to the token file.\n        encoding: The encoding to use.\n        errors: The error handling of the encoding to use.\n    \"\"\"\n    path.write_text(token + NEW_LINE, encoding, errors)\n</code></pre>"},{"location":"reference/tokens/#aoc.tokens.remove_token","title":"<code>remove_token(path: Path = TOKEN_PATH) -&gt; None</code>","text":"<p>Removes the token at the given <code>path</code>.</p> <p>This function does nothing if the <code>path</code> does not exist.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the token file.</p> <code>TOKEN_PATH</code> Source code in <code>aoc/tokens.py</code> <pre><code>def remove_token(path: Path = TOKEN_PATH) -&gt; None:\n    \"\"\"Removes the token at the given `path`.\n\n    This function does nothing if the `path` does not exist.\n\n    Arguments:\n        path: The path to the token file.\n    \"\"\"\n    path.unlink(missing_ok=True)\n</code></pre>"},{"location":"reference/versions/","title":"Versions","text":""},{"location":"reference/versions/#aoc.versions.version_info","title":"<code>version_info = get_version(aoc)</code>  <code>module-attribute</code>","text":"<p>The version of the library, represented as <code>Version</code>.</p>"},{"location":"reference/ext/constants/","title":"Constants","text":"<p>Commonly used constants.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.ZERO","title":"<code>ZERO: Literal[0] = 0</code>  <code>module-attribute</code>","text":"<p>Zero (<code>0</code>) literal.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.ONE","title":"<code>ONE: Literal[1] = 1</code>  <code>module-attribute</code>","text":"<p>One (<code>1</code>) literal.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.NEGATIVE_ONE","title":"<code>NEGATIVE_ONE: Literal[-1] = -1</code>  <code>module-attribute</code>","text":"<p>Negative one (<code>-1</code>) literal.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.EMPTY","title":"<code>EMPTY = str()</code>  <code>module-attribute</code>","text":"<p>The empty string.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.NEW_LINE","title":"<code>NEW_LINE = '\\n'</code>  <code>module-attribute</code>","text":"<p>One new line character.</p>"},{"location":"reference/ext/constants/#aoc.ext.constants.DOUBLE_NEW_LINE","title":"<code>DOUBLE_NEW_LINE = NEW_LINE + NEW_LINE</code>  <code>module-attribute</code>","text":"<p>Two new line characters.</p>"},{"location":"reference/ext/splits/","title":"Splits","text":""},{"location":"reference/ext/splits/#aoc.ext.splits.Split","title":"<code>Split = Parse[List[str]]</code>  <code>module-attribute</code>","text":"<p>Represents split functions.</p>"},{"location":"reference/ext/splits/#aoc.ext.splits.split_lines","title":"<code>split_lines = split_at(NEW_LINE)</code>  <code>module-attribute</code>","text":"<p>Splits the <code>string</code> by <code>NEW_LINE</code>.</p>"},{"location":"reference/ext/splits/#aoc.ext.splits.split_double_lines","title":"<code>split_double_lines = split_at(DOUBLE_NEW_LINE)</code>  <code>module-attribute</code>","text":"<p>Splits the <code>string</code> by <code>DOUBLE_NEW_LINE</code>.</p>"},{"location":"reference/ext/splits/#aoc.ext.splits.split_at","title":"<code>split_at(separator: str) -&gt; Split</code>","text":"<p>Creates <code>split</code> functions that split the <code>string</code> by <code>separator</code>.</p> <p>Parameters:</p> Name Type Description Default <code>separator</code> <code>str</code> <p>The separator to split the string by.</p> required <p>Returns:</p> Type Description <code>Split</code> <p>The <code>split</code> function created.</p> Source code in <code>aoc/ext/splits.py</code> <pre><code>def split_at(separator: str) -&gt; Split:\n    \"\"\"Creates `split` functions that split the `string` by `separator`.\n\n    Arguments:\n        separator: The separator to split the string by.\n\n    Returns:\n        The `split` function created.\n    \"\"\"\n\n    def split(string: str) -&gt; List[str]:\n        return string.split(separator)\n\n    return split\n</code></pre>"},{"location":"reference/ext/splits/#aoc.ext.splits.split_whitespace","title":"<code>split_whitespace(string: str) -&gt; List[str]</code>","text":"<p>Splits the <code>string</code> by whitespace.</p> <p>This is equivalent to:</p> <pre><code>string.split()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>string</code> <code>str</code> <p>The string to split.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>The split result.</p> Source code in <code>aoc/ext/splits.py</code> <pre><code>def split_whitespace(string: str) -&gt; List[str]:\n    \"\"\"Splits the `string` by whitespace.\n\n    This is equivalent to:\n\n    ```python\n    string.split()\n    ```\n\n    Arguments:\n        string: The string to split.\n\n    Returns:\n        The split result.\n    \"\"\"\n    return string.split()\n</code></pre>"}]}